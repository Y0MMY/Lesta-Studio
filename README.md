# Lesta-Studio
- ## №1
> На языке С/С++, написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути.

> Объяснить плюсы и минусы обеих реализаций.

> C/C++ example:

> bool isEven(int value){return value%2==0;}

 [Ответ](https://github.com/Y0MMY/Lesta-Studio/blob/main/sample1.cpp) 

- ## №2
> На языке С++, написать минимум по 2 класса реализовывающих циклический буфер.

> Объяснить плюсы и минусы каждой реализации.

[Статический буффер](https://github.com/Y0MMY/Lesta-Studio/blob/main/arraybuf.cpp) <br>
[Динамический буффер](https://github.com/Y0MMY/Lesta-Studio/blob/main/dynamicbuf.cpp) 

Основное различие между двумя реализациями заключается в том, как хранится буфер. Реализация 1 использует массив фиксированного размера, в то время как реализация 2 использует динамический массив (std::vector). Вот некоторые плюсы и минусы каждой реализации:

1.Плюсы реализации 1 (массив фиксированного размера):

*Размер буфера известен во время компиляции, поэтому буфер может быть выделен в стеке, что быстрее, чем выделение в куче.
Нет никаких накладных расходов на выделение памяти или риска утечки памяти, поскольку буфер выделяется статически.*


2.Плюсы реализации 2 (динамический массив):

*Размер буфера может быть выбран во время выполнения, поэтому буфер может увеличиваться или уменьшаться по мере необходимости.
Размер буфера можно изменять динамически, чтобы он мог адаптироваться к изменяющимся требованиям к памяти.
Реализация более гибкая, чем массив фиксированного размера.*

- ## №3

>На языке С/С++, написать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел.

>Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным).

>Объяснить почему вы считаете, что функция соответствует заданным критериям.

[Ответ](https://github.com/Y0MMY/Lesta-Studio/blob/main/quicksort.cpp) 
Важно отметить, что самый быстрый алгоритм сортировки будет зависеть от конкретных характеристик входных данных и аппаратного обеспечения, на котором он выполняется. В некоторых случаях алгоритмы сортировки, не основанные на сравнении, могут быть быстрее, чем алгоритмы, основанные на сравнении, особенно если входные данные обладают определенными свойствами. В других случаях другие алгоритмы сортировки могут быть быстрее
